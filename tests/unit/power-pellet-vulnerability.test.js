/**
 * Tests for power pellet vulnerability mechanics
 * Verifies enemy state changes, timer system, and visual indicators
 */

import { Enemy } from '../../client/src/components/Enemy.js';
import { AIController } from '../../client/src/components/AIController.js';
import { GameEngine } from '../../client/src/components/GameEngine.js';

// Mock MazeRenderer for testing
class MockMazeRenderer {
    constructor() {
        this.canvas = { width: 800, height: 600 };
    }
    
    worldToGrid(x, y) {
        return { x: Math.floor(x / 20), y: Math.floor(y / 20) };
    }
    
    gridToWorld(x, y) {
        return { x: x * 20 + 10, y: y * 20 + 10 };
    }
    
    worldToScreen(x, y) {
        return { x, y };
    }
    
    isWallAtPosition(x, y) {
        return false; // No walls for testing
    }
    
    getMazeDimensions() {
        return { width: 800, height: 600 };
    }
    
    getCellSize() {
        return 20;
    }
}

describe('Power Pellet Vulnerability Mechanics', () => {
    let enemy;
    let aiController;
    let mockMazeRenderer;
    
    beforeEach(() => {
        mockMazeRenderer = new MockMazeRenderer();
        enemy = new Enemy(100, 100, mockMazeRenderer, 'chaser');
        aiController = new AIController(mockMazeRenderer);
    });
    
    describe('Enemy Vulnerability State Changes', () => {
        test('should set enemy to vulnerable state', () => {
            expect(enemy.getIsVulnerable()).toBe(false);
            
            enemy.setVulnerable(true, 5000);
            
            expect(enemy.getIsVulnerable()).toBe(true);
            expect(enemy.getState()).toBe('vulnerable');
            expect(enemy.vulnerabilityTimer).toBe(5000);
        });
        
        test('should slow down enemy when vulnerable', () => {
            const originalSpeed = enemy.speed;
            
            enemy.setVulnerable(true, 5000);
            
            expect(enemy.speed).toBe(originalSpeed * 0.5);
            expect(enemy.originalSpeed).toBe(originalSpeed);
        });
        
        test('should restore original speed when vulnerability ends', () => {
            const originalSpeed = enemy.speed;
            
            enemy.setVulnerable(true, 5000);
            enemy.setVulnerable(false);
            
            expect(enemy.speed).toBe(originalSpeed);
            expect(enemy.getIsVulnerable()).toBe(false);
            expect(enemy.getState()).toBe('chase');
        });
        
        test('should clear path when becoming vulnerable', () => {
            enemy.path = [{ x: 1, y: 1 }, { x: 2, y: 2 }];
            enemy.pathIndex = 1;
            
            enemy.setVulnerable(true, 5000);
            
            expect(enemy.path).toEqual([]);
            expect(enemy.pathIndex).toBe(0);
        });
        
        test('should not double-modify speed if already vulnerable', () => {
            const originalSpeed = enemy.speed;
            
            enemy.setVulnerable(true, 5000);
            const vulnerableSpeed = enemy.speed;
            
            enemy.setVulnerable(true, 3000); // Set vulnerable again
            
            expect(enemy.speed).toBe(vulnerableSpeed);
            expect(enemy.originalSpeed).toBe(originalSpeed);
        });
    });
    
    describe('Vulnerability Timer System', () => {
        test('should countdown vulnerability timer', () => {
            enemy.setVulnerable(true, 5000);
            
            enemy.updateVulnerabilityState(1000);
            expect(enemy.vulnerabilityTimer).toBe(4000);
            
            enemy.updateVulnerabilityState(2000);
            expect(enemy.vulnerabilityTimer).toBe(2000);
        });
        
        test('should automatically end vulnerability when timer expires', () => {
            enemy.setVulnerable(true, 1000);
            
            enemy.updateVulnerabilityState(1500);
            
            expect(enemy.getIsVulnerable()).toBe(false);
            expect(enemy.getState()).toBe('chase');
            expect(enemy.color).toBe(enemy.originalColor);
        });
        
        test('should not update timer when not vulnerable', () => {
            expect(enemy.getIsVulnerable()).toBe(false);
            
            enemy.updateVulnerabilityState(1000);
            
            expect(enemy.vulnerabilityTimer).toBe(0);
        });
    });
    
    describe('Visual Indicators', () => {
        test('should change color during different vulnerability phases', () => {
            const originalColor = enemy.originalColor;
            
            // Safe phase (> 3000ms)
            enemy.setVulnerable(true, 5000);
            enemy.updateVulnerabilityState(0);
            expect(enemy.color).toBe('#0000FF');
            
            // Warning phase (1000-3000ms)
            enemy.vulnerabilityTimer = 2000;
            enemy.updateVulnerabilityState(0);
            expect(enemy.color).toBe('#0000FF'); // Should be blue in first flash cycle
            
            // Critical phase (< 1000ms)
            enemy.vulnerabilityTimer = 500;
            enemy.updateVulnerabilityState(0);
            // Color should be either blue or original (flashing)
            expect(['#0000FF', originalColor]).toContain(enemy.color);
        });
        
        test('should restore original color when vulnerability ends', () => {
            const originalColor = enemy.originalColor;
            
            enemy.setVulnerable(true, 1000);
            enemy.updateVulnerabilityState(1500); // Timer expires
            
            expect(enemy.color).toBe(originalColor);
        });
    });
    
    describe('AIController Vulnerability Management', () => {
        beforeEach(() => {
            // Add some enemies to the controller
            for (let i = 0; i < 3; i++) {
                const testEnemy = new Enemy(100 + i * 50, 100, mockMazeRenderer, 'chaser');
                aiController.enemies.push(testEnemy);
            }
        });
        
        test('should make all enemies vulnerable', () => {
            aiController.setAllEnemiesVulnerable(true, 5000);
            
            expect(aiController.getVulnerableEnemyCount()).toBe(3);
            expect(aiController.hasVulnerableEnemies()).toBe(true);
            
            for (const enemy of aiController.enemies) {
                expect(enemy.getIsVulnerable()).toBe(true);
            }
        });
        
        test('should restore all enemies to normal state', () => {
            aiController.setAllEnemiesVulnerable(true, 5000);
            aiController.setAllEnemiesVulnerable(false);
            
            expect(aiController.getVulnerableEnemyCount()).toBe(0);
            expect(aiController.hasVulnerableEnemies()).toBe(false);
            
            for (const enemy of aiController.enemies) {
                expect(enemy.getIsVulnerable()).toBe(false);
            }
        });
        
        test('should track remaining vulnerability time', () => {
            const duration = 5000;
            aiController.setAllEnemiesVulnerable(true, duration);
            
            const remainingTime = aiController.getRemainingVulnerabilityTime();
            expect(remainingTime).toBeGreaterThan(4000);
            expect(remainingTime).toBeLessThanOrEqual(duration);
        });
        
        test('should return zero remaining time when not vulnerable', () => {
            expect(aiController.getRemainingVulnerabilityTime()).toBe(0);
        });
        
        test('should only affect enemies not already in desired state', () => {
            // Make first enemy vulnerable manually
            aiController.enemies[0].setVulnerable(true, 3000);
            
            const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
            
            aiController.setAllEnemiesVulnerable(true, 5000);
            
            // Should only affect 2 enemies (the ones that weren't already vulnerable)
            expect(consoleSpy).toHaveBeenCalledWith(
                expect.stringContaining('Made 2 enemies vulnerable')
            );
            
            consoleSpy.mockRestore();
        });
    });
    
    describe('Enemy Avoidance Behavior', () => {
        test('should calculate avoidance target when vulnerable', () => {
            const playerPos = { x: 200, y: 200 };
            
            enemy.setVulnerable(true, 5000);
            const avoidanceTarget = enemy.getAvoidanceTarget(playerPos);
            
            // Enemy should try to move away from player
            const directionFromPlayer = {
                x: enemy.x - playerPos.x,
                y: enemy.y - playerPos.y
            };
            
            // Normalize expected direction
            const length = Math.sqrt(directionFromPlayer.x ** 2 + directionFromPlayer.y ** 2);
            if (length > 0) {
                directionFromPlayer.x /= length;
                directionFromPlayer.y /= length;
            }
            
            // Avoidance target should be in the direction away from player
            const expectedX = enemy.x + directionFromPlayer.x * 200;
            const expectedY = enemy.y + directionFromPlayer.y * 200;
            
            expect(avoidanceTarget.x).toBeCloseTo(expectedX, 1);
            expect(avoidanceTarget.y).toBeCloseTo(expectedY, 1);
        });
        
        test('should use avoidance target when vulnerable during pathfinding', () => {
            const playerPos = { x: 200, y: 200 };
            
            enemy.setVulnerable(true, 5000);
            
            const behaviorTarget = enemy.getBehaviorTarget(playerPos, {});
            const avoidanceTarget = enemy.getAvoidanceTarget(playerPos);
            
            // When vulnerable, behavior target should be avoidance target
            // (This would be tested in the actual updatePathfinding method)
            expect(typeof behaviorTarget).toBe('object');
            expect(typeof avoidanceTarget).toBe('object');
        });
    });
    
    describe('Integration with Game Engine', () => {
        test('should handle power pellet collection with level-based duration', () => {
            // Mock canvas and context
            const mockCanvas = { width: 800, height: 600 };
            const mockCtx = {
                fillRect: jest.fn(),
                fillStyle: '',
                strokeStyle: '',
                lineWidth: 0,
                beginPath: jest.fn(),
                arc: jest.fn(),
                fill: jest.fn(),
                stroke: jest.fn(),
                save: jest.fn(),
                restore: jest.fn(),
                textAlign: '',
                font: '',
                fillText: jest.fn()
            };
            
            const gameEngine = new GameEngine(mockCanvas, mockCtx);
            
            // Test level 1 duration
            gameEngine.gameState.level = 1;
            gameEngine.handlePowerPelletCollection();
            
            expect(gameEngine.powerPelletEndTime).toBeTruthy();
            const level1Duration = gameEngine.powerPelletEndTime - Date.now();
            expect(level1Duration).toBeGreaterThan(9000); // Should be close to 10 seconds
            
            // Test higher level duration (should be shorter)
            gameEngine.gameState.level = 10;
            gameEngine.handlePowerPelletCollection();
            
            const level10Duration = gameEngine.powerPelletEndTime - Date.now();
            expect(level10Duration).toBeLessThan(level1Duration);
            expect(level10Duration).toBeGreaterThan(5000); // Should not go below 5 seconds
        });
    });
});